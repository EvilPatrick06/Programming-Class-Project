#!/usr/bin/env python3
"""
VS Code Extension Management Script
Automatically manages VS Code extensions across codespaces by:
1. Tracking currently installed extensions in extensions.txt
2. Installing missing extensions on startup
3. Updating all extensions to latest versions
4. Synchronizing extensions across different codespaces

Usage:
- Run automatically on codespace startup
- Can be run manually to sync extensions
"""

import subprocess
import sys
import os
import json
import time
import re

def show_notification(message, message_type="info"):
    """Show a notification in the terminal"""
    colors = {
        "info": "\033[94m",      # Blue
        "success": "\033[92m",   # Green  
        "warning": "\033[93m",   # Yellow
        "error": "\033[91m"      # Red
    }
    reset = "\033[0m"
    
    icons = {
        "info": "‚ÑπÔ∏è",
        "success": "‚úÖ", 
        "warning": "‚ö†Ô∏è",
        "error": "‚ùå"
    }
    
    color = colors.get(message_type, colors["info"])
    icon = icons.get(message_type, icons["info"])
    
    print("=" * 80)
    print(f"{color}{icon} VS Code Extension Manager{reset}")
    print("=" * 80)
    print(f"{color}{message}{reset}")
    print("=" * 80)
    print()

def get_installed_extensions():
    """Get list of currently installed VS Code extensions"""
    try:
        result = subprocess.run(["code", "--list-extensions"], 
                              capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            extensions = []
            for ext in result.stdout.split('\n'):
                ext = ext.strip()
                # Skip VS Code output headers that might get mixed in
                if ext.startswith("Extensions installed on Codespaces:"):
                    continue
                # Filter out invalid or system messages
                if ext and re.match(r'^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$', ext):
                    extensions.append(ext)
            return extensions
        else:
            print(f"‚ö†Ô∏è  Warning: Could not get installed extensions: {result.stderr}")
            return []
    except subprocess.TimeoutExpired:
        print("‚ö†Ô∏è  Warning: Timeout getting installed extensions")
        return []
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Error getting installed extensions: {e}")
        return []

def read_extensions_file():
    """Read the extensions.txt file and return list of required extensions"""
    extensions_file = os.path.join(os.getcwd(), ".vscode/extensions.txt")
    
    if not os.path.exists(extensions_file):
        print(f"üìÑ Creating new extensions file: {extensions_file}")
        return []
    
    try:
        with open(extensions_file, 'r') as f:
            lines = f.readlines()
        
        extensions = []
        for line in lines:
            line = line.strip()
            # Skip empty lines and comments
            if line and not line.startswith('#'):
                # Skip VS Code output headers that might get mixed in
                if line.startswith("Extensions installed on Codespaces:"):
                    continue
                # Validate extension format (publisher.extension-name)
                if re.match(r'^[a-zA-Z0-9\-_]+\.[a-zA-Z0-9\-_]+$', line):
                    extensions.append(line)
                else:
                    print(f"‚ö†Ô∏è  Invalid extension format: {line}")
        
        return extensions
    except Exception as e:
        print(f"‚ùå Error reading extensions file: {e}")
        return []

def write_extensions_file(extensions):
    """Write the list of extensions to extensions.txt"""
    extensions_file = os.path.join(os.getcwd(), ".vscode/extensions.txt")
    
    try:
        # Create header comment
        header = '''# VS Code Extensions List
# This file tracks all extensions that should be installed in this workspace
# Format: publisher.extension-name
# Lines starting with # are comments and will be ignored
# Auto-generated by extension_manager.py

'''
        
        # Group extensions by category (based on publisher or common patterns)
        categorized = {
            'Python Development': [],
            'Git and Version Control': [],
            'Remote Development': [],
            'Markdown': [],
            'Themes and UI': [],
            'General Development': [],
            'Other': []
        }
        
        for ext in sorted(extensions):
            if 'python' in ext.lower():
                categorized['Python Development'].append(ext)
            elif 'git' in ext.lower() or 'gitlens' in ext.lower():
                categorized['Git and Version Control'].append(ext)
            elif 'remote' in ext.lower() or 'container' in ext.lower():
                categorized['Remote Development'].append(ext)
            elif 'markdown' in ext.lower():
                categorized['Markdown'].append(ext)
            elif 'theme' in ext.lower() or 'color' in ext.lower() or 'icon' in ext.lower():
                categorized['Themes and UI'].append(ext)
            elif any(dev in ext.lower() for dev in ['vscode', 'code', 'editor', 'intellisense']):
                categorized['General Development'].append(ext)
            else:
                categorized['Other'].append(ext)
        
        # Write to file
        with open(extensions_file, 'w') as f:
            f.write(header)
            
            for category, exts in categorized.items():
                if exts:
                    f.write(f"# {category}\n")
                    for ext in exts:
                        f.write(f"{ext}\n")
                    f.write("\n")
        
        print(f"‚úÖ Updated extensions file with {len(extensions)} extensions")
        
    except Exception as e:
        print(f"‚ùå Error writing extensions file: {e}")

def install_extension(extension_id):
    """Install a single VS Code extension with progress indicators"""
    try:
        print(f"üì¶ Installing: {extension_id}")
        
        # Start the installation process
        process = subprocess.Popen(
            ["code", "--install-extension", extension_id, "--force"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        # Show progress while installing
        import threading
        import time
        
        def show_progress():
            dots = 0
            while process.poll() is None:
                print(f"\r   üì• Downloading and installing{'.' * (dots % 4):<4}", end='', flush=True)
                dots += 1
                time.sleep(0.5)
        
        progress_thread = threading.Thread(target=show_progress)
        progress_thread.daemon = True
        progress_thread.start()
        
        # Wait for completion with timeout
        try:
            stdout, stderr = process.communicate(timeout=120)
            print()  # New line after progress dots
            
            if process.returncode == 0:
                print(f"‚úÖ Installed: {extension_id}")
                return True
            else:
                print(f"‚ùå Failed to install {extension_id}: {stderr.strip()}")
                return False
                
        except subprocess.TimeoutExpired:
            process.kill()
            print(f"\n‚è∞ Timeout installing {extension_id}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error installing {extension_id}: {e}")
        return False

def update_all_extensions():
    """Update all installed extensions to latest versions"""
    try:
        print("üîÑ Updating all extensions to latest versions...")
        
        # Get list of installed extensions with versions
        result = subprocess.run(["code", "--list-extensions", "--show-versions"], 
                              capture_output=True, text=True, timeout=30)
        
        if result.returncode != 0:
            print("‚ö†Ô∏è  Could not get extension versions for update check")
            return False
        
        installed_with_versions = result.stdout.strip().split('\n')
        extensions_to_update = []
        
        for ext_version in installed_with_versions:
            if '@' in ext_version:
                ext_id = ext_version.split('@')[0]
                extensions_to_update.append(ext_id)
        
        if not extensions_to_update:
            print("‚úÖ No extensions found to update")
            return True
        
        print(f"üîÑ Updating {len(extensions_to_update)} extensions...")
        
        success_count = 0
        for i, ext_id in enumerate(extensions_to_update, 1):
            try:
                print(f"üîÑ [{i}/{len(extensions_to_update)}] Updating: {ext_id}")
                result = subprocess.run(["code", "--install-extension", ext_id, "--force"], 
                                      capture_output=True, text=True, timeout=60)
                if result.returncode == 0:
                    success_count += 1
                    print(f"‚úÖ Updated: {ext_id}")
                else:
                    print(f"‚ö†Ô∏è  Update warning for {ext_id}: {result.stderr}")
            except Exception as e:
                print(f"‚ùå Error updating {ext_id}: {e}")
        
        print(f"‚úÖ Successfully updated {success_count}/{len(extensions_to_update)} extensions")
        return True
        
    except Exception as e:
        print(f"‚ùå Error updating extensions: {e}")
        return False

def sync_extensions():
    """Main function to synchronize VS Code extensions"""
    
    show_notification("üîÑ Starting VS Code Extension Sync...", "info")
    
    print("üöÄ VS Code Extension Manager")
    print("=" * 50)
    print("üì¶ This script manages VS Code extensions across codespaces")
    print("üîÑ Operations: Install missing ‚Ä¢ Update existing ‚Ä¢ Track changes")
    print("=" * 50)
    
    # Step 1: Get currently installed extensions
    print("\nüìã Step 1: Scanning installed extensions...")
    installed_extensions = get_installed_extensions()
    print(f"Found {len(installed_extensions)} installed extensions")
    
    # Step 2: Read required extensions from file
    print("\nüìÑ Step 2: Reading extensions requirements...")
    required_extensions = read_extensions_file()
    print(f"Found {len(required_extensions)} required extensions")
    
    # Step 3: Update the extensions.txt file with any new extensions
    print("\nüîÑ Step 3: Updating extensions tracking file...")
    
    # Find extensions that are installed but not in the file
    new_extensions = set(installed_extensions) - set(required_extensions)
    if new_extensions:
        print(f"üì¶ Found {len(new_extensions)} new extensions to track:")
        for ext in sorted(new_extensions):
            print(f"   + {ext}")
        
        # Add new extensions to the required list
        all_extensions = sorted(set(installed_extensions) | set(required_extensions))
        write_extensions_file(all_extensions)
    else:
        print("‚úÖ No new extensions to track")
    
    # Step 4: Install missing extensions
    print("\nüì¶ Step 4: Installing missing extensions...")
    missing_extensions = set(required_extensions) - set(installed_extensions)
    
    if missing_extensions:
        print(f"üì¶ Found {len(missing_extensions)} missing extensions:")
        for ext in sorted(missing_extensions):
            print(f"   - {ext}")
        
        print(f"\nüöÄ Starting installation of {len(missing_extensions)} extensions...")
        print("=" * 60)
        
        install_success = 0
        for i, ext in enumerate(sorted(missing_extensions), 1):
            print(f"\nüì• [{i}/{len(missing_extensions)}] Installing extension:")
            if install_extension(ext):
                install_success += 1
        
        print("=" * 60)
        print(f"‚úÖ Successfully installed {install_success}/{len(missing_extensions)} extensions")
        
        if install_success > 0:
            show_notification(f"‚úÖ Installed {install_success} missing extensions!", "success")
    else:
        print("‚úÖ All required extensions are already installed")
    
    # Step 5: Update all extensions
    print("\nüîÑ Step 5: Updating extensions to latest versions...")
    update_success = update_all_extensions()
    
    if update_success:
        show_notification("‚úÖ Extension sync completed successfully!", "success")
    else:
        show_notification("‚ö†Ô∏è  Extension sync completed with some warnings", "warning")
    
    # Step 6: Final status report
    print("\nüìä Final Status Report:")
    final_installed = get_installed_extensions()
    print(f"   üì¶ Total extensions installed: {len(final_installed)}")
    print(f"   üìÑ Extensions tracked in file: {len(required_extensions + list(new_extensions))}")
    print(f"   ‚úÖ Sync operation: {'Completed' if update_success else 'Completed with warnings'}")
    
    print("\nüí° Tips:")
    print("   ‚Ä¢ Extensions are automatically tracked in .vscode/extensions.txt")
    print("   ‚Ä¢ Install new extensions normally - they'll be tracked on next sync")
    print("   ‚Ä¢ This script runs automatically on codespace startup")
    print("   ‚Ä¢ Manual sync: python3 .vscode/extension_manager.py")

def main():
    """Main function"""
    try:
        # Check if we're in a codespace environment
        if not (os.environ.get('CODESPACES') or os.environ.get('GITPOD_WORKSPACE_ID') or 
                os.path.exists('/workspaces')):
            print("This script is designed for codespace environments.")
            return
        
        # Check if running in container setup mode
        container_setup_mode = os.environ.get('CONTAINER_SETUP_MODE', 'false').lower() == 'true'
        
        if container_setup_mode:
            print("üîß Running in container setup mode - minimal delays, essential extensions only")
            time.sleep(1)  # Minimal delay in container setup
        else:
            print("üñ•Ô∏è  Running in VS Code mode - full extension sync")
            time.sleep(3)  # Normal delay for VS Code context
        
        sync_extensions()
        
    except KeyboardInterrupt:
        show_notification("‚ö†Ô∏è  Extension sync interrupted by user", "warning")
        print("\n‚ö†Ô∏è  Extension sync interrupted by user")
    except Exception as e:
        show_notification(f"‚ùå Error during extension sync: {e}", "error")
        print(f"‚ùå Error during extension sync: {e}")

if __name__ == "__main__":
    main()