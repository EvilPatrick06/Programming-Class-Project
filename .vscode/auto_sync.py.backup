#!/usr/bin/env python3
"""
Codespace Auto-Sync Script
Updates your codespace with:
1. Latest Ubuntu system packages and security updates
2. Latest code FROM GitHub (main or Testing branch)

Shows VS Code dialogs and notifications instead of terminal prompts

Purpose: 
- Check for and install Ubuntu package updates
- Pull/sync FROM GitHub TO your codespace
Note: To push your changes TO GitHub, use git_sync.py instead
"""

import subprocess
import sys
import os
import json
import time
import     print("üöÄ Codespace Auto-Sync Script")
    print("=" * 60)
    print("üîÑ This script updates your codespace with:")
    print("   ‚Ä¢ Ubuntu version upgrades (when available)")
    print("   ‚Ä¢ Latest Ubuntu package updates & security patches")
    print("   ‚Ä¢ Latest code from GitHub repository")
    print("üì§ To push your changes TO GitHub, use the git_sync.py script instead")
    print("=" * 60)e
import textwrap
import threading

def create_vscode_dialog_html(title, message, options):
    """Create an HTML file for VS Code dialog simulation"""
    html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #cccccc;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }}
        .dialog {{
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            padding: 24px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }}
        .title {{
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #ffffff;
        }}
        .message {{
            margin-bottom: 24px;
            line-height: 1.5;
            white-space: pre-wrap;
        }}
        .options {{
            display: flex;
            flex-direction: column;
            gap: 8px;
        }}
        .option {{
            background: #0e639c;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }}
        .option:hover {{
            background: #1177bb;
        }}
        .option.secondary {{
            background: #5a5a5a;
        }}
        .option.secondary:hover {{
            background: #6a6a6a;
        }}
        .instructions {{
            margin-top: 16px;
            font-size: 12px;
            color: #999999;
            text-align: center;
        }}
    </style>
</head>
<body>
    <div class="dialog">
        <div class="title">{title}</div>
        <div class="message">{message}</div>
        <div class="options">
            {"".join([f'<button class="option {'secondary' if i > 0 else ''}" onclick="selectOption({i})">{opt}</button>' for i, opt in enumerate(options)])}
        </div>
        <div class="instructions">
            Click an option above or respond in the terminal with the number (1-{len(options)})
        </div>
    </div>
    <script>
        function selectOption(index) {{
            // This would ideally communicate back to the Python script
            // For now, we'll just highlight the selection
            document.querySelectorAll('.option').forEach((btn, i) => {{
                if (i === index) {{
                    btn.style.background = '#28a745';
                    btn.textContent += ' ‚úì';
                }}
            }});
        }}
    </script>
</body>
</html>
"""
    return html_content

def show_vscode_notification(message, message_type="info"):
    """Show a VS Code notification using the integrated terminal"""
    # Create a colorful notification in the terminal
    colors = {
        "info": "\033[94m",      # Blue
        "success": "\033[92m",   # Green  
        "warning": "\033[93m",   # Yellow
        "error": "\033[91m"      # Red
    }
    reset = "\033[0m"
    
    icons = {
        "info": "‚ÑπÔ∏è",
        "success": "‚úÖ", 
        "warning": "‚ö†Ô∏è",
        "error": "‚ùå"
    }
    
    color = colors.get(message_type, colors["info"])
    icon = icons.get(message_type, icons["info"])
    
    # Clear the terminal and show prominent message
    print("\033[2J\033[H")  # Clear screen and move cursor to top
    print("=" * 80)
    print(f"{color}{icon} VS Code Auto-Sync Notification{reset}")
    print("=" * 80)
    print(f"{color}{message}{reset}")
    print("=" * 80)
    print()

def show_vscode_dialog(title, message, options):
    """Show a prominent dialog-like interface in the terminal"""
    # Create HTML file for potential viewing
    html_content = create_vscode_dialog_html(title, message, options)
    
    # Create temp file in current directory instead of system temp for easier cleanup
    html_file = f".tmp_dialog_{int(time.time())}.html"
    with open(html_file, 'w') as f:
        f.write(html_content)
    
    # Show in terminal with nice formatting
    print("\033[2J\033[H")  # Clear screen
    print("‚îå" + "‚îÄ" * 78 + "‚îê")
    print(f"‚îÇ{title:^78}‚îÇ")
    print("‚îú" + "‚îÄ" * 78 + "‚î§")
    
    # Word wrap the message
    wrapped_lines = textwrap.wrap(message, width=76)
    for line in wrapped_lines:
        print(f"‚îÇ {line:<76} ‚îÇ")
    
    print("‚îú" + "‚îÄ" * 78 + "‚î§")
    print("‚îÇ Options:                                                                   ‚îÇ")
    
    for i, option in enumerate(options):
        option_text = f"{i+1}. {option}"
        if len(option_text) > 74:
            option_text = option_text[:71] + "..."
        print(f"‚îÇ {option_text:<76} ‚îÇ")
    
    print("‚îî" + "‚îÄ" * 78 + "‚îò")
    print()
    
    # Note: We don't open in VS Code browser to avoid leftover tabs with weird URLs
    # The terminal-based dialog is sufficient and cleaner
    
    return html_file

def get_vscode_input(prompt, options=None):
    """Get user input through VS Code-style dialog interface"""
    html_file = None
    try:
        if options:
            # Show the dialog-style interface
            html_file = show_vscode_dialog("Repository Auto-Sync", prompt, options)
            
            # Get input from terminal
            while True:
                try:
                    choice = input(f"\nEnter your choice (1-{len(options)}): ").strip()
                    if choice.isdigit():
                        idx = int(choice) - 1
                        if 0 <= idx < len(options):
                            return options[idx]
                    print("Invalid choice. Please try again.")
                except (EOFError, KeyboardInterrupt):
                    return None
        else:
            # Simple text input with nice formatting
            print("\n" + "="*60)
            print(f"üìù {prompt}")
            print("="*60)
            try:
                return input("> ").strip()
            except (EOFError, KeyboardInterrupt):
                return None
    except Exception as e:
        print(f"Error getting input: {e}")
        # Fallback to simple terminal input
        try:
            if options:
                print(f"\n{prompt}")
                for i, option in enumerate(options):
                    print(f"{i+1}. {option}")
                while True:
                    try:
                        choice = input(f"Enter your choice (1-{len(options)}): ").strip()
                        if choice.isdigit():
                            idx = int(choice) - 1
                            if 0 <= idx < len(options):
                                return options[idx]
                        print("Invalid choice. Please try again.")
                    except (EOFError, KeyboardInterrupt):
                        return None
            else:
                return input(f"{prompt}: ").strip()
        except (EOFError, KeyboardInterrupt):
            return None
    finally:
        # Always clean up HTML file, regardless of how the function exits
        if html_file and os.path.exists(html_file):
            try:
                os.unlink(html_file)
            except:
                pass

def check_git_status():
    """Check if there are any uncommitted changes or unpushed commits"""
    try:
        # Check for uncommitted changes
        status_result = subprocess.run("git status --porcelain", 
                                     shell=True, capture_output=True, text=True)
        has_changes = bool(status_result.stdout.strip())
        
        # Check for unpushed commits
        try:
            unpushed_result = subprocess.run("git log @{u}..HEAD", 
                                           shell=True, capture_output=True, text=True)
            has_unpushed = unpushed_result.returncode == 0 and bool(unpushed_result.stdout.strip())
        except:
            has_unpushed = False
        
        return has_changes, has_unpushed
    except Exception:
        return False, False

def check_ubuntu_updates():
    """Check if Ubuntu package updates are available"""
    try:
        print("üîç Checking for Ubuntu package updates...")
        show_vscode_notification("üîç Checking for Ubuntu updates...", "info")
        
        # Update package lists
        update_result = subprocess.run("sudo apt update", 
                                     shell=True, capture_output=True, text=True)
        
        if update_result.returncode != 0:
            print("‚ö†Ô∏è  Warning: Could not update package lists")
            return False, 0
        
        # Check for upgradable packages
        upgradable_result = subprocess.run("apt list --upgradable 2>/dev/null | grep -v 'WARNING'", 
                                         shell=True, capture_output=True, text=True)
        
        upgradable_lines = [line for line in upgradable_result.stdout.split('\n') 
                           if line.strip() and not line.startswith('Listing')]
        
        return True, len(upgradable_lines)
        
    except Exception as e:
        print(f"‚ùå Error checking package updates: {e}")
        return False, 0

def check_ubuntu_version_upgrade():
    """Check if a new Ubuntu version/release is available"""
    try:
        print("üîç Checking for Ubuntu version upgrades...")
        
        # Check for new Ubuntu release
        release_check = subprocess.run("sudo do-release-upgrade -c", 
                                     shell=True, capture_output=True, text=True)
        
        # Parse the output to determine if upgrade is available
        output = release_check.stdout + release_check.stderr
        
        # Check for different scenarios
        if "New release" in output and "available" in output:
            # Extract version info if possible
            lines = output.split('\n')
            for line in lines:
                if "New release" in line and "available" in line:
                    print(f"üìà {line.strip()}")
                    return True, line.strip()
            return True, "New Ubuntu release available"
        
        elif "no development version" in output.lower() or "no new release found" in output.lower():
            print("‚úÖ Ubuntu version is current (no new LTS release available)")
            return False, "No new LTS release available"
        
        elif "upgrade to the latest non-LTS" in output:
            print("üí° Non-LTS development versions available (LTS upgrade not recommended)")
            return False, "Only non-LTS development versions available"
        
        else:
            print("‚úÖ Ubuntu version appears to be current")
            return False, "No new release detected"
            
    except Exception as e:
        print(f"‚ùå Error checking Ubuntu version upgrade: {e}")
        return False, f"Error: {e}"

def install_ubuntu_updates():
    """Install Ubuntu updates with user progress feedback"""
    try:
        print("üì¶ Installing Ubuntu updates...")
        show_vscode_notification("üì¶ Installing Ubuntu updates... This may take a few minutes.", "info")
        
        # Install updates with progress
        upgrade_process = subprocess.Popen(
            ["sudo", "apt", "upgrade", "-y"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            bufsize=1
        )
        
        # Show progress dots while updating
        def show_progress():
            dots = 0
            while upgrade_process.poll() is None:
                print(f"\rüì¶ Installing updates{'.' * (dots % 4):<4}", end='', flush=True)
                dots += 1
                time.sleep(1)
        
        progress_thread = threading.Thread(target=show_progress)
        progress_thread.daemon = True
        progress_thread.start()
        
        # Wait for completion
        upgrade_process.wait()
        print()  # New line after progress dots
        
        if upgrade_process.returncode == 0:
            show_vscode_notification("‚úÖ Ubuntu updates installed successfully!", "success")
            print("‚úÖ Ubuntu updates installed successfully!")
            
            # Also run autoremove to clean up
            print("üßπ Cleaning up unnecessary packages...")
            autoremove_result = subprocess.run("sudo apt autoremove -y", 
                                             shell=True, capture_output=True, text=True)
            if autoremove_result.returncode == 0:
                print("‚úÖ Package cleanup completed!")
            
            return True
        else:
            show_vscode_notification("‚ùå Failed to install some updates", "warning")
            print("‚ùå Some updates may have failed to install")
            return False
            
    except Exception as e:
        show_vscode_notification(f"‚ùå Error installing updates: {e}", "error")
        print(f"‚ùå Error installing updates: {e}")
        return False

def handle_ubuntu_updates():
    """Handle Ubuntu updates check and installation"""
    try:
        # First check for Ubuntu version upgrades
        print("üîÑ Checking Ubuntu system status...")
        upgrade_available, upgrade_info = check_ubuntu_version_upgrade()
        
        # Then check for package updates
        check_success, update_count = check_ubuntu_updates()
        
        if not check_success:
            show_vscode_notification("‚ö†Ô∏è  Could not check for Ubuntu package updates", "warning")
            if upgrade_available:
                print(f"üí° However, Ubuntu version upgrade is available: {upgrade_info}")
            return
        
        # Handle version upgrade if available
        if upgrade_available:
            print(f"üìà Ubuntu version upgrade available: {upgrade_info}")
            
            version_upgrade_choice = get_vscode_input(
                f"Ubuntu version upgrade available: {upgrade_info}\n\nWould you like to upgrade Ubuntu version?",
                [
                    "Yes, upgrade Ubuntu version (recommended for LTS releases)",
                    "No, just update packages for now",
                    "Skip all updates"
                ]
            )
            
            if version_upgrade_choice and "Yes" in version_upgrade_choice:
                print("üöÄ Starting Ubuntu version upgrade...")
                show_vscode_notification("üöÄ Starting Ubuntu version upgrade... This may take 30+ minutes.", "info")
                
                # Perform the upgrade
                upgrade_result = subprocess.run("sudo do-release-upgrade -f DistUpgradeViewNonInteractive", 
                                              shell=True, capture_output=False)
                
                if upgrade_result.returncode == 0:
                    show_vscode_notification("‚úÖ Ubuntu version upgrade completed! Restart may be required.", "success")
                    print("‚úÖ Ubuntu version upgrade completed!")
                    print("üí° You may need to restart your codespace to complete the upgrade.")
                else:
                    show_vscode_notification("‚ö†Ô∏è  Ubuntu version upgrade had issues. Check manually.", "warning")
                    print("‚ö†Ô∏è  Ubuntu version upgrade completed with issues. Please check manually.")
                
                return  # Skip package updates after version upgrade
            
            elif version_upgrade_choice and "Skip all" in version_upgrade_choice:
                show_vscode_notification("‚è≠Ô∏è  All Ubuntu updates skipped", "info")
                print("‚è≠Ô∏è  All Ubuntu updates skipped")
                return
        
        # Handle package updates
        if update_count == 0:
            if not upgrade_available:
                show_vscode_notification("‚úÖ Ubuntu system is fully up to date!", "success")
                print("‚úÖ Ubuntu packages are already up to date!")
            else:
                print("‚úÖ Ubuntu packages are up to date (version upgrade available but skipped)")
            return
        
        print(f"üì¶ Found {update_count} package updates available")
        
        # Ask user if they want to install package updates
        install_updates = get_vscode_input(
            f"Found {update_count} Ubuntu package updates available. Install them now?",
            [
                "Yes, install package updates now", 
                "No, skip package updates (install manually later)",
                "Show me what packages will be updated first"
            ]
        )
        
        if install_updates is None:
            return
        
        if "Show me what packages" in install_updates:
            print("üìã Packages that will be updated:")
            subprocess.run("apt list --upgradable", shell=True)
            
            # Ask again after showing the list
            proceed = get_vscode_input(
                "Proceed with installing these package updates?",
                ["Yes, install all package updates", "No, skip package updates"]
            )
            
            if proceed and "Yes" in proceed:
                install_ubuntu_updates()
            else:
                show_vscode_notification("‚è≠Ô∏è  Ubuntu package updates skipped", "info")
                print("‚è≠Ô∏è  Ubuntu package updates skipped")
        
        elif "Yes" in install_updates:
            install_ubuntu_updates()
        else:
            show_vscode_notification("‚è≠Ô∏è  Ubuntu package updates skipped", "info")
            print("‚è≠Ô∏è  Ubuntu package updates skipped. You can install them later with: sudo apt upgrade")
            
    except Exception as e:
        show_vscode_notification(f"‚ùå Error handling Ubuntu updates: {e}", "error")
        print(f"‚ùå Error handling Ubuntu updates: {e}")

def sync_repository():
    """Main sync function with VS Code dialogs - focuses on syncing FROM GitHub"""
    
    # Show welcome message
    show_vscode_notification("üöÄ Codespace Auto-Sync Started! Checking for updates...", "info")
    
    print("üöÄ Codespace Auto-Sync Script")
    print("=" * 60)
    print("ÔøΩ This script updates your codespace with:")
    print("   ‚Ä¢ Latest Ubuntu package updates")
    print("   ‚Ä¢ Latest code from GitHub repository")
    print("üì§ To push your changes TO GitHub, use the git_sync.py script instead")
    print("=" * 60)
    
    # First, handle Ubuntu updates
    print("\nüêß UBUNTU SYSTEM UPDATES")
    print("-" * 30)
    handle_ubuntu_updates()
    
    print("\nüìÇ REPOSITORY SYNC")
    print("-" * 20)
    
    # Check if we're in a git repository
    if not os.path.exists('.git'):
        show_vscode_notification("‚ùå Not in a git repository!", "error")
        return
    
    # Get current branch
    try:
        current_branch = subprocess.run("git branch --show-current", 
                                      shell=True, capture_output=True, text=True).stdout.strip()
    except:
        current_branch = "unknown"
    
    print(f"Current branch: {current_branch}")
    
    # Auto-switch to Testing branch if we're on main and Testing exists
    if current_branch == "main":
        print("üí° Codespace prefers Testing branch for development work...")
        
        # Check if Testing branch exists locally
        testing_exists_local = subprocess.run("git branch --list Testing", 
                                            shell=True, capture_output=True, text=True)
        
        # Check if Testing branch exists on remote
        testing_exists_remote = subprocess.run("git ls-remote --heads origin Testing", 
                                             shell=True, capture_output=True, text=True)
        
        if testing_exists_local.stdout.strip():
            # Testing branch exists locally, switch to it
            print("üîÑ Switching to existing Testing branch...")
            switch_result = subprocess.run("git checkout Testing", shell=True, capture_output=True, text=True)
            if switch_result.returncode == 0:
                current_branch = "Testing"
                show_vscode_notification("‚úÖ Auto-switched to Testing branch for development!", "success")
                print("‚úÖ Switched to Testing branch!")
                # Pull latest changes
                subprocess.run("git pull origin Testing 2>/dev/null || true", shell=True)
        elif testing_exists_remote.stdout.strip():
            # Testing branch exists on remote, check it out
            print("üîÑ Checking out Testing branch from remote...")
            checkout_result = subprocess.run("git checkout -b Testing origin/Testing", 
                                           shell=True, capture_output=True, text=True)
            if checkout_result.returncode == 0:
                current_branch = "Testing"
                show_vscode_notification("‚úÖ Auto-switched to Testing branch from remote!", "success")
                print("‚úÖ Checked out Testing branch from remote!")
        else:
            # No Testing branch exists, offer to create it
            create_testing = get_vscode_input(
                "No Testing branch found. Create Testing branch for development work?",
                ["Yes, create Testing branch", "No, stay on main"]
            )
            
            if create_testing and "Yes" in create_testing:
                print("üîÑ Creating Testing branch...")
                create_result = subprocess.run("git checkout -b Testing", shell=True, capture_output=True, text=True)
                if create_result.returncode == 0:
                    current_branch = "Testing"
                    show_vscode_notification("‚úÖ Created Testing branch for development!", "success")
                    print("‚úÖ Created Testing branch!")
    
    # Check git status
    has_changes, has_unpushed = check_git_status()
    
    # If everything is clean, offer branch sync options
    if not has_changes and not has_unpushed:
        print("‚úÖ No local changes found - ready to sync from GitHub!")
        
        action = get_vscode_input(
            "How would you like to update your codespace?",
            [
                "Sync fresh from GitHub main branch (replaces everything)",
                "Sync fresh from GitHub Testing branch (replaces everything)", 
                "Pull latest changes from current branch",
                "Switch to a different branch first",
                "Nothing - continue working"
            ]
        )
        
        if action is None:
            show_vscode_notification("‚ùå Sync cancelled by user", "warning")
            return
        
        if "main branch" in action:
            print("üîÑ Syncing fresh from GitHub main branch...")
            print("‚ö†Ô∏è  This will replace ALL local files with the latest from main!")
            result = subprocess.run(["/bin/bash", ".vscode/sync-repo.sh", "main"], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                show_vscode_notification("‚úÖ Successfully synced from main branch!", "success")
                print("‚úÖ Codespace synced from main branch!")
                print("üîÑ Reloading VS Code window to reflect changes...")
                # Optional: reload VS Code window
                try:
                    subprocess.run(["code", "--command", "workbench.action.reloadWindow"], 
                                 capture_output=True, timeout=2)
                except:
                    pass
            else:
                show_vscode_notification(f"‚ùå Sync failed: {result.stderr}", "error")
                print(f"‚ùå Sync failed: {result.stderr}")
        
        elif "Testing branch" in action:
            print("üîÑ Syncing fresh from GitHub Testing branch...")
            print("‚ö†Ô∏è  This will replace ALL local files with the latest from Testing!")
            result = subprocess.run(["/bin/bash", ".vscode/sync-repo.sh", "Testing"], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                show_vscode_notification("‚úÖ Successfully synced from Testing branch!", "success")
                print("‚úÖ Codespace synced from Testing branch!")
                print("üîÑ Reloading VS Code window to reflect changes...")
                # Optional: reload VS Code window
                try:
                    subprocess.run(["code", "--command", "workbench.action.reloadWindow"], 
                                 capture_output=True, timeout=2)
                except:
                    pass
            else:
                show_vscode_notification(f"‚ùå Sync failed: {result.stderr}", "error")
                print(f"‚ùå Sync failed: {result.stderr}")
        
        elif "Pull latest changes" in action:
            print("üîÑ Pulling latest changes from current branch...")
            result = subprocess.run("git pull", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                show_vscode_notification("‚úÖ Successfully pulled latest changes!", "success")
                print("‚úÖ Successfully pulled latest changes!")
            else:
                show_vscode_notification(f"‚ùå Failed to pull changes: {result.stderr}", "error")
                print(f"‚ùå Failed: {result.stderr}")
        
        elif "Switch to a different branch" in action:
            # Get available branches
            try:
                branches_result = subprocess.run("git branch -r", shell=True, capture_output=True, text=True)
                if branches_result.returncode == 0:
                    branches = [b.strip().replace('origin/', '') for b in branches_result.stdout.split('\n') 
                              if b.strip() and 'origin/' in b and '->' not in b]
                    if branches:
                        selected_branch = get_vscode_input("Select branch to switch to:", branches)
                        if selected_branch:
                            print(f"üîÑ Switching to branch: {selected_branch}")
                            result = subprocess.run(f"git checkout {selected_branch}", 
                                                  shell=True, capture_output=True, text=True)
                            if result.returncode == 0:
                                show_vscode_notification(f"‚úÖ Switched to branch: {selected_branch}", "success")
                                # After switching, offer to pull latest changes
                                pull_after_switch = get_vscode_input(
                                    f"Pull latest changes from {selected_branch}?",
                                    ["Yes, pull latest changes", "No, stay as is"]
                                )
                                if pull_after_switch and "Yes" in pull_after_switch:
                                    subprocess.run("git pull", shell=True)
                                    show_vscode_notification(f"‚úÖ Pulled latest changes from {selected_branch}!", "success")
                            else:
                                show_vscode_notification(f"‚ùå Failed to switch branch: {result.stderr}", "error")
                    else:
                        show_vscode_notification("No remote branches found", "warning")
            except Exception as e:
                show_vscode_notification(f"Error getting branches: {e}", "error")
        
        else:
            show_vscode_notification("‚úÖ Codespace ready! Happy coding! üéâ", "success")
            print("‚úÖ Continuing with current state. Happy coding!")
    
    else:
        # There are changes or unpushed commits - warn user
        status_msg = []
        if has_changes:
            status_msg.append("uncommitted changes")
        if has_unpushed:
            status_msg.append("unpushed commits")
        
        message = f"Found {' and '.join(status_msg)} in your codespace."
        print(f"‚ö†Ô∏è  {message}")
        print("üí° Remember: This script is for syncing FROM GitHub, not pushing TO GitHub")
        
        action = get_vscode_input(
            f"You have {' and '.join(status_msg)}. What would you like to do?",
            [
                "View my changes first",
                "Discard my changes and sync fresh from GitHub",
                "Keep my changes and skip sync (I'll handle manually)",
                "Open git_sync.py script to push my changes"
            ]
        )
        
        if action is None:
            show_vscode_notification("‚ùå Sync cancelled by user", "warning")
            return
        
        if "View my changes" in action:
            print("ÔøΩ Showing your local changes...")
            print("\nüìã Git status:")
            subprocess.run("git status", shell=True)
            print("\nüìã Git diff (your changes):")
            subprocess.run("git diff", shell=True)
            
            # Ask what to do next
            next_action = get_vscode_input(
                "After reviewing your changes, what would you like to do?",
                [
                    "Keep my changes (skip sync)",
                    "Discard my changes and sync from GitHub",
                    "Push my changes first (open git_sync.py)"
                ]
            )
            
            if next_action and "Keep my changes" in next_action:
                show_vscode_notification("‚úÖ Keeping your changes. Use git_sync.py to push them later.", "info")
            elif next_action and "Discard my changes" in next_action:
                confirm = get_vscode_input(
                    "‚ö†Ô∏è  Are you sure you want to discard ALL your changes? This cannot be undone!",
                    ["Yes, discard all changes", "No, keep my changes"]
                )
                if confirm and "Yes" in confirm:
                    branch_choice = get_vscode_input(
                        "Which GitHub branch should we sync from?",
                        ["main", "Testing"]
                    )
                    if branch_choice:
                        print(f"üîÑ Discarding changes and syncing fresh from {branch_choice}...")
                        subprocess.run("git reset --hard HEAD", shell=True)
                        subprocess.run("git clean -fd", shell=True)
                        result = subprocess.run(["/bin/bash", ".vscode/sync-repo.sh", branch_choice], 
                                              capture_output=True, text=True)
                        if result.returncode == 0:
                            show_vscode_notification(f"‚úÖ Synced fresh from {branch_choice} branch!", "success")
                        else:
                            show_vscode_notification(f"‚ùå Sync failed: {result.stderr}", "error")
            elif next_action and "Push my changes" in next_action:
                print("üöÄ Opening git_sync.py script to help you push your changes...")
                show_vscode_notification("üí° Running git_sync.py to help you push your changes to GitHub", "info")
                subprocess.run([sys.executable, ".vscode/git_sync.py"], capture_output=False)
        
        elif "Discard my changes" in action:
            confirm = get_vscode_input(
                "‚ö†Ô∏è  Are you sure you want to discard ALL your changes and sync fresh? This cannot be undone!",
                ["Yes, discard and sync fresh", "No, keep my changes"]
            )
            
            if confirm and "Yes" in confirm:
                branch_choice = get_vscode_input(
                    "Which GitHub branch should we sync from?",
                    ["main", "Testing"]
                )
                
                if branch_choice:
                    print(f"üîÑ Discarding all changes and syncing fresh from {branch_choice}...")
                    subprocess.run("git reset --hard HEAD", shell=True)
                    subprocess.run("git clean -fd", shell=True)
                    result = subprocess.run(["/bin/bash", ".vscode/sync-repo.sh", branch_choice], 
                                          capture_output=True, text=True)
                    if result.returncode == 0:
                        show_vscode_notification(f"‚úÖ Synced fresh from {branch_choice} branch!", "success")
                    else:
                        show_vscode_notification(f"‚ùå Sync failed: {result.stderr}", "error")
        
        elif "git_sync.py script" in action:
            print("üöÄ Opening git_sync.py script to help you push your changes...")
            show_vscode_notification("üí° Running git_sync.py to help you push your changes to GitHub", "info")
            subprocess.run([sys.executable, ".vscode/git_sync.py"], capture_output=False)
        
        else:
            show_vscode_notification("‚úÖ Keeping your changes. Use git_sync.py when ready to push.", "info")
            print("‚úÖ Keeping your changes. Use git_sync.py when you're ready to push to GitHub.")

def cleanup_temp_files():
    """Clean up temporary HTML files created by the script"""
    try:
        # Clean up current directory temp files
        for file in os.listdir('.'):
            if file.startswith('.tmp_dialog_') and file.endswith('.html'):
                try:
                    os.unlink(file)
                except:
                    pass
        
        # Clean up system temp directory HTML files (from older versions)
        import glob
        temp_pattern = os.path.join(tempfile.gettempdir(), 'tmp*.html')
        for html_file in glob.glob(temp_pattern):
            try:
                # Only delete files that are more than 10 minutes old to avoid conflicts
                if os.path.getmtime(html_file) < time.time() - 600:
                    os.unlink(html_file)
            except:
                pass
    except Exception as e:
        # Don't fail the script for cleanup issues
        pass

def main():
    """Main function"""
    try:
        # Add a small delay to ensure VS Code is fully loaded
        time.sleep(2)
        
        # Check if this is likely a codespace environment
        if not (os.environ.get('CODESPACES') or os.environ.get('GITPOD_WORKSPACE_ID') or 
                os.path.exists('/workspaces')):
            print("This script is designed for codespace environments.")
            return
        
        sync_repository()
        
    except KeyboardInterrupt:
        show_vscode_notification("‚ö†Ô∏è  Auto-sync interrupted by user", "warning")
        print("\n‚ö†Ô∏è  Auto-sync interrupted by user")
    except Exception as e:
        show_vscode_notification(f"‚ùå Error during auto-sync: {e}", "error")
        print(f"‚ùå Error during auto-sync: {e}")
    finally:
        # Always clean up temporary files
        cleanup_temp_files()

if __name__ == "__main__":
    main()